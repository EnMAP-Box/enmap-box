import argparse
import os
import re
import subprocess
import warnings
from os import makedirs
from pathlib import Path
from typing import Dict, List, Union

from qgis.core import QgsApplication, QgsProcessingAlgorithm, QgsProcessingDestinationParameter, \
    QgsProcessingParameterDefinition

import enmapbox
from enmapbox.algorithmprovider import EnMAPBoxProcessingProvider
from enmapbox.testing import start_app
from enmapboxprocessing.enmapalgorithm import EnMAPProcessingAlgorithm, Group
from enmapboxprocessing.glossary import injectGlossaryLinks

rootCodeRepo = Path(__file__).parent.parent

dryRun = False  # a fast way to check if all parameters are documented

PREFIX_AUTOGEN = '..\n  ## AUTOGENERATED '

# environment to run qgis_process from python shell command
QGIS_PROCESS_ENV = os.environ.copy()
for k in ['QGIS_CUSTOM_CONFIG_PATH', 'QT3D_RENDERER']:
    if k in QGIS_PROCESS_ENV:
        QGIS_PROCESS_ENV.pop(k)


def parse_text_sections(text: str) -> Dict[Union[str, int], str]:
    """
    Splits the intput text into manually defined and autogenerated sections
        key = int -> manually defined section
        key = str -> name of autogenerated section
    """
    rx = re.compile(r'(\.\.\n  ## AUTOGENERATED (.*) START)')
    matches = rx.findall(text)
    if len(matches) == 0:
        return {0: text}

    results = dict()
    current_start = 0
    current_man_section = 0
    for match in matches:
        section = match[1]
        key_start = match[0]
        key_end = key_start[0:-5] + 'END\n'

        i0 = text.find(key_start)
        ie = text.find(key_end) + len(key_end)

        if i0 > current_start:
            results[current_man_section] = text[current_start: i0]

        results[section] = text[i0:ie]

        current_start = ie
        current_man_section += 1

    if current_start < len(text):
        results[current_man_section + 1] = text[current_start:]
    return results


def update_rst(text_old: str, text_new: str) -> str:
    """
    Updates the autogenerated sections in text_old by autogenerated sections in text_new
    """
    old_sections = parse_text_sections(text_old)
    new_sections = parse_text_sections(text_new)

    merges_section = old_sections.copy()
    for k, text in new_sections.items():
        if isinstance(k, str):
            merges_section[k] = new_sections[k]

    final = ''
    for key, text in merges_section.items():
        if isinstance(key, str):  # autogenerated section
            if len(final) > 0 and not final[-1] in ['\n']:
                final += '\n'
        final += text
    return final


def create_or_update_rst(file, text: str):
    """
    Create or update a rst file that contains the text.
    In case the rst file already exists, it will be updated by
    autogenerated content in text.
    """
    file = Path(file)
    if isinstance(text, list):
        text = '\n'.join(text)

    if file.is_file():
        # update text with existing, none-autogenerated filetext
        with open(file, 'r') as f:
            old_text = f.read()

        if PREFIX_AUTOGEN in old_text:
            text = update_rst(old_text, text)
        else:
            warnings.warn(f'Overwrite none-autogenerated file:\n    {file}')

    with open(file, 'w', encoding='utf-8') as f:
        f.write(text)

    print(f'Created {file}')


def generateAlgorithmRSTs(rootRst: Union[Path, str],
                          algorithms: List[QgsProcessingAlgorithm]) -> List[str]:
    """
    Create an rst file for each provided QgsProcessingAlgorithm.
    """
    rootRst = Path(rootRst)
    if isinstance(algorithms, QgsProcessingAlgorithm):
        algorithms = [algorithms]

    for alg in algorithms:

        afilename = alg.displayName().lower()
        for c in r'/() ':
            afilename = afilename.replace(c, '_')
        filename = rootRst / groupFolderName(alg.group()) / '{}.rst'.format(afilename)

        section_adds = dict()

        # check for old-style processing_algorithms_includes files and include the rst code
        filename_includes = rootRst.parent / f'{rootRst.name}_includes' / groupFolderName(
            alg.group()) / '{}.rst'.format(afilename)
        if filename_includes.is_file():
            with open(filename_includes) as f:
                text = f.read()
                section_adds['DESCRIPTION'] = text

        text = v3(alg, section_adds=section_adds)

        create_or_update_rst(filename, text)


def groupFolderName(group: str) -> str:
    name = group.lower()
    for c in ' ,*':
        name = name.replace(c, '_')
    return name


def generateGroupRSTs(rootRst, algorithms: List[QgsProcessingAlgorithm]) -> List[str]:
    rootRst = Path(rootRst)

    groups = set([a.group() for a in algorithms])

    index_files: List[str] = []
    for group in groups:
        # create group folder
        groupFolder = rootRst / groupFolderName(group)
        makedirs(groupFolder, exist_ok=True)

        # create group index.rst
        # create group index.rst
        title = [
            f'.. _{group}:\n',
            f'{group}',
            f'{'=' * len(group)}',
        ]
        text = wrapAutoGenerated(title, 'TITLE')

        toc = [
            '.. toctree::',
            '   :maxdepth: 0',
            '   :glob:\n',
            '   *\n'
        ]
        text += wrapAutoGenerated(toc, 'TOC')

        filename = groupFolder / 'index.rst'
        create_or_update_rst(filename, text)
        index_files.append(f'{groupFolder.name}/{filename.name}')

    # write processing_algorithm.rst
    title = ['Processing Algorithms',
             '*********************\n']
    toc = ['.. toctree::',
           '    :maxdepth: 1\n']
    for f in index_files:
        toc.append(f'    {f}')

    text = wrapAutoGenerated(title, 'TITLE') + wrapAutoGenerated(toc, 'TOC')
    filename = rootRst / 'processing_algorithms.rst'
    create_or_update_rst(filename, text)

    return index_files


def doc_repo_root() -> Path:
    if 'PATH_DOCU_REPO' in os.environ:
        rootDocRepo = Path(os.environ['PATH_DOCU_REPO'])
    else:
        rootDocRepo = rootCodeRepo.parent / 'enmap-box-documentation'
    return rootDocRepo


def generateRST(rootRst: Union[Path, str],
                algorithmIds: List[str] = None
                ):
    rootRst = Path(rootRst)
    assert rootRst.is_dir()
    print(rootCodeRepo)
    print(rootRst)

    assert isinstance(EnMAPBoxProcessingProvider.instance(), EnMAPBoxProcessingProvider)
    makedirs(rootRst, exist_ok=True)

    # filter algorithms
    if algorithmIds is None:
        algs = EnMAPBoxProcessingProvider.instance().algorithms()
        for alg in EnMAPBoxProcessingProvider.instance().algorithms():
            if Group.Experimental.name in alg.group():
                raise RuntimeError('Remove experimental algorithms from final release!')

    else:
        algs = QgsApplication.instance().processingRegistry().algorithms()

        algs = [a for a in algs if
                a.id() in algorithmIds or a.name() in algorithmIds]

    # create group folders, <group>/index.rst and processing_algorithms.rst
    print(f'Create *.rst files for {len(algs)} algorithms')
    generateGroupRSTs(rootRst, algs)
    generateAlgorithmRSTs(rootRst, algs)

    s = ""


def wrapWithNewLines(text: str) -> str:
    """
    Ensures that the input text begins and ends with a newline character
    In case it does not end with a newline, 2 empty lines will be appended
    :param text: str
    :return: str
    """

    if isinstance(text, str) and len(text) > 0:
        if text[0] != '\n':
            text = '\n' + text
        if text[-1] != '\n':
            text += '\n\n'
        return text
    else:
        return ''


def wrapAutoGenerated(rst_text: Union[str, list], section: str) -> str:
    if isinstance(rst_text, list):
        rst_text = '\n'.join(rst_text)

    """Wraps autogenerated content with start and end markers"""
    return f"{PREFIX_AUTOGEN}{section} START\n{wrapWithNewLines(rst_text)}\n{PREFIX_AUTOGEN}{section} END\n\n"


def v3(alg: QgsProcessingAlgorithm, section_adds: dict = None):
    """

    :param alg: QgsProcessingAlgorithm
    :param section_adds: dictionary with rst code snippeds to append to an autogenerated section.
    """
    if isinstance(alg, EnMAPProcessingAlgorithm):
        helpParameters = {k: v for k, v in alg.helpParameters()}
    else:
        helpParameters = dict()

    if section_adds is None:
        section_adds = dict()

    # Title Section
    title = alg.displayName()
    dotline = '*' * len(title)
    title_text = f".. _{title}:\n\n{dotline}\n{title}\n{dotline}\n"
    title_text = utilsConvertHtmlLinksToRstLinks(title_text)  # Convert any HTML links

    text = wrapAutoGenerated(title_text, "TITLE")
    text += wrapWithNewLines(section_adds.get('TITLE'))

    # Description Section
    description_text = injectGlossaryLinks(alg.shortDescription())
    description_text = utilsConvertHtmlLinksToRstLinks(description_text)
    text += wrapAutoGenerated(description_text, "DESCRIPTION")
    text += wrapWithNewLines(section_adds.get('DESCRIPTION'))

    # Parameters Section
    param_text = '**Parameters**\n\n'
    outputsHeadingCreated = False
    for pd in alg.parameterDefinitions():
        assert isinstance(pd, QgsProcessingParameterDefinition)

        pdhelp = helpParameters.get(pd.description(), pd.description())

        if not outputsHeadingCreated and isinstance(pd, QgsProcessingDestinationParameter):
            param_text += '**Outputs**\n\n'
            outputsHeadingCreated = True

        param_text += f'\n:guilabel:`{pd.description()}` [{pd.type()}]\n'
        pdhelp = injectGlossaryLinks(pdhelp)
        pdhelp = utilsConvertHtmlLinksToRstLinks(pdhelp)  # Convert HTML links in help text
        for line in pdhelp.split('\n'):
            param_text += f'    {line}\n'

        if pd.defaultValue() is not None:
            if isinstance(pd.defaultValue(), str) and '\n' in pd.defaultValue():
                param_text += '    Default::\n\n'
                for line in pd.defaultValue().split('\n'):
                    param_text += f'        {line}\n'
            else:
                param_text += f'    Default: *{pd.defaultValue()}*\n\n'

    text += wrapAutoGenerated(param_text, "PARAMETERS")
    text += wrapWithNewLines(section_adds.get('PARAMETERS'))

    # Command-line usage
    helptext = qgis_process_help(alg)
    helptext = helptext[helptext.find('----------------\nArguments\n----------------'):]
    helptext = utilsConvertHtmlLinksToRstLinks(helptext)  # Convert HTML links in usage text

    usage_text = f"**Command-line usage**\n\n``>qgis_process help {alg.id()}``::\n\n"
    usage_text += '\n'.join([f'    {line}' for line in helptext.splitlines()])

    text += wrapAutoGenerated(usage_text, "COMMAND USAGE")
    text += wrapWithNewLines(section_adds.get('COMMAND USAGE'))

    return text


def qgis_process_help(algorithm: QgsProcessingAlgorithm) -> str:
    result = subprocess.run(['qgis_process', 'help', algorithm.id()],
                            env=QGIS_PROCESS_ENV,
                            stdout=subprocess.PIPE, stderr=subprocess.PIPE
                            )
    assert result.returncode == 0
    helptext = result.stdout.decode('cp1252')
    return helptext


def utilsConvertHtmlLinksToRstLinks(text: str) -> str:
    """Convert all HTML-style links in the text to RST-style links."""
    links = utilsFindHtmlWeblinks(text)  # Find all HTML links in the text
    for html_link in links:
        rst_link = utilsHtmlWeblinkToRstWeblink(html_link)
        text = text.replace(html_link, rst_link)
    return text


def utilsFindHtmlWeblinks(text) -> List[str]:
    match_: re.Match
    starts = [match_.start() for match_ in re.finditer('<a href="', text)]
    ends = [match_.start() + 4 for match_ in re.finditer('</a>', text)]
    assert len(starts) == len(ends)
    links = [text[start:end] for start, end in zip(starts, ends)]
    return links


def utilsHtmlWeblinkToRstWeblink(htmlText: str) -> str:
    assert htmlText.startswith('<a href="'), htmlText
    assert htmlText.endswith('</a>'), htmlText
    link, name = htmlText[9:-4].split('">')
    rstText = f'`{name} <{link}>`_'
    return rstText


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Generates the documentation for EnMAPBox processing algorithms ',
                                     formatter_class=argparse.RawTextHelpFormatter)

    doc_root_default = doc_repo_root() / 'source' / 'usr_section' / 'usr_manual' / 'processing_algorithms'

    parser.add_argument('-r', '--rst_root',
                        required=False,
                        default=str(doc_root_default),
                        help=f'Root folder to write the RST files. Defaults to {doc_root_default}')

    parser.add_argument('-a', '--algs',
                        required=False,
                        nargs='*',
                        default=None,
                        help='List of algorithms ids to generate the documentation for')

    args = parser.parse_args()

    rootRst = Path(args.rst_root)
    if not rootRst.is_absolute():
        rootRst = rootCodeRepo / rootRst

    assert rootRst.is_dir(), f'Directory does not exists: {rootRst}. Use --rst_root to specify location.'

    start_app()
    enmapbox.initAll()
    generateRST(rootRst, args.algs)
