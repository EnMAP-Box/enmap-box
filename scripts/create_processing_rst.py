import argparse
import datetime
import os
import re
import subprocess
import warnings
from concurrent.futures.thread import ThreadPoolExecutor
from os import makedirs
from pathlib import Path
from typing import Dict, List, Union

from qgis.core import QgsApplication, QgsProcessingAlgorithm, QgsProcessingDestinationParameter, \
    QgsProcessingParameterDefinition

import enmapbox
from enmapbox.algorithmprovider import EnMAPBoxProcessingProvider
from enmapbox.testing import start_app
from enmapboxprocessing.enmapalgorithm import EnMAPProcessingAlgorithm, Group
from enmapboxprocessing.glossary import injectGlossaryLinks

rootCodeRepo = Path(__file__).parent.parent

dryRun = False  # a fast way to check if all parameters are documented

PREFIX_AUTOGEN = '..\n  ## AUTOGENERATED '

# environment to run qgis_process from python shell command
QGIS_PROCESS_ENV = os.environ.copy()
for k in ['QGIS_CUSTOM_CONFIG_PATH', 'QT3D_RENDERER']:
    if k in QGIS_PROCESS_ENV:
        QGIS_PROCESS_ENV.pop(k)


def parseRSTSections(text: str) -> Dict[Union[str, int], str]:
    """
    Splits the intput text into manually defined and autogenerated sections
        key = int -> manually defined section
        key = str -> name of autogenerated section
    """
    rx = re.compile(r'(\.\.\n  ## AUTOGENERATED (.*) START)')
    matches = rx.findall(text)
    if len(matches) == 0:
        return {0: text}

    results = dict()
    current_start = 0
    current_man_section = 0
    for match in matches:
        section = match[1]
        key_start = match[0]
        key_end = key_start[0:-5] + 'END\n'

        i0 = text.find(key_start)
        ie = text.find(key_end) + len(key_end)

        if i0 > current_start:
            results[current_man_section] = text[current_start: i0]

        results[section] = text[i0:ie]

        current_start = ie
        current_man_section += 1

    if current_start < len(text):
        results[current_man_section + 1] = text[current_start:]
    return results


def update_rst(text_old: str, text_new: str) -> str:
    """
    Updates the autogenerated sections in text_old by autogenerated sections in text_new
    """
    old_sections = parseRSTSections(text_old)
    new_sections = parseRSTSections(text_new)

    merges_section = old_sections.copy()
    for k, text in new_sections.items():
        if isinstance(k, str):
            merges_section[k] = new_sections[k]

    final = ''
    for key, text in merges_section.items():
        if isinstance(key, str):  # autogenerated section
            if len(final) > 0 and not final[-1] in ['\n']:
                final += '\n'
        final += text
    return final


def create_or_update_rst(file, text: str):
    """
    Create or update a rst file that contains the text.
    In case the rst file already exists, it will be updated by
    autogenerated content in text.
    """
    file = Path(file)
    if isinstance(text, list):
        text = '\n'.join(text)

    if file.is_file():
        # update text with existing, none-autogenerated filetext
        with open(file, 'r') as f:
            old_text = f.read()

        if PREFIX_AUTOGEN in old_text:
            text = update_rst(old_text, text)
        else:
            warnings.warn(f'Overwrite none-autogenerated file:\n    {file}')

    with open(file, 'w', encoding='utf-8') as f:
        f.write(text)

    return file


def generateAlgorithmRSTs(rootRst: Union[Path, str],
                          algorithms: List[QgsProcessingAlgorithm],
                          load_process_help: bool = True) -> List[str]:
    """
    Create an rst file for each provided QgsProcessingAlgorithm.
    """
    rootRst = Path(rootRst)
    if isinstance(algorithms, QgsProcessingAlgorithm):
        algorithms = [algorithms]

    n = len(algorithms)
    if load_process_help:
        print(f'Collect qgis_process help string for {n} algorithms (takes a while)... ', end='')
        t0 = datetime.datetime.now()
        qgis_process_help = collectQgsProcessAlgorithmHelp(algorithms, run_async=True)
        print(f'Done: {datetime.datetime.now() - t0}')
    else:
        qgis_process_help = dict()

    print(f'Create rst files for {n} algorithms...')
    for i, alg in enumerate(algorithms):

        afilename = alg.displayName().lower()
        for c in r'/() ':
            afilename = afilename.replace(c, '_')
        filename = rootRst / groupFolderName(alg.group()) / '{}.rst'.format(afilename)

        section_adds = dict()

        # check for old-style processing_algorithms_includes files and include the rst code
        filename_includes = rootRst.parent / f'{rootRst.name}_includes' / groupFolderName(
            alg.group()) / '{}.rst'.format(afilename)
        if filename_includes.is_file():
            with open(filename_includes) as f:
                text = f.read()
                section_adds['DESCRIPTION'] = text

        text = v3(alg, section_adds=section_adds, qgis_process_help=qgis_process_help)

        path = create_or_update_rst(filename, text)
        print(f'Created {i + 1}/{n}: {path}')


def groupFolderName(group: str) -> str:
    name = group.lower()
    for c in ' ,*':
        name = name.replace(c, '_')
    return name


def generateGroupRSTs(rootRst, algorithms: List[QgsProcessingAlgorithm]) -> List[str]:
    rootRst = Path(rootRst)

    groups = sorted(set([a.group() for a in algorithms]))

    index_files: List[str] = []
    n = len(groups)
    print(f'Create index.rst files for {n} groups...')
    for i, group in enumerate(groups):
        # create group folder
        groupFolder = rootRst / groupFolderName(group)
        makedirs(groupFolder, exist_ok=True)

        group_points = '=' * len(group)
        title = [
            f'.. _{group}:\n',
            f'{group}',
            f'{group_points}',
        ]
        text = wrapAutoGenerated(title, 'TITLE')

        toc = [
            '.. toctree::',
            '   :maxdepth: 0',
            '   :glob:\n',
            '   *\n'
        ]
        text += wrapAutoGenerated(toc, 'TOC')

        filename = groupFolder / 'index.rst'
        path = create_or_update_rst(filename, text)
        index_files.append(f'{groupFolder.name}/{filename.name}')
        print(f'Created {i + 1}/{n}: {path}')

    # write processing_algorithm.rst
    title = [
        '.. _Processing Algorithms:\n',
        'Processing Algorithms',
        '*********************\n']
    toc = ['.. toctree::',
           '    :maxdepth: 1\n']
    for f in index_files:
        toc.append(f'    {f}')

    text = wrapAutoGenerated(title, 'TITLE') + wrapAutoGenerated(toc, 'TOC')
    filename = rootRst / 'processing_algorithms.rst'
    path = create_or_update_rst(filename, text)
    print(f'Created {path}')
    return index_files


def doc_repo_root() -> Path:
    if 'PATH_DOCU_REPO' in os.environ:
        rootDocRepo = Path(os.environ['PATH_DOCU_REPO'])
    else:
        rootDocRepo = rootCodeRepo.parent / 'enmap-box-documentation'
    return rootDocRepo


def generateRST(rootRst: Union[Path, str],
                algorithmIds: List[str] = None,
                load_process_help: bool = True):
    rootRst = Path(rootRst)
    assert rootRst.is_dir()
    print(rootCodeRepo)
    print(rootRst)

    assert isinstance(EnMAPBoxProcessingProvider.instance(), EnMAPBoxProcessingProvider)
    makedirs(rootRst, exist_ok=True)

    # filter algorithms
    if algorithmIds is None:
        algs = EnMAPBoxProcessingProvider.instance().algorithms()
        for alg in EnMAPBoxProcessingProvider.instance().algorithms():
            if Group.Experimental.name in alg.group():
                raise RuntimeError('Remove experimental algorithms from final release!')

    else:
        algs = QgsApplication.instance().processingRegistry().algorithms()

        algs = [a for a in algs if
                a.id() in algorithmIds or a.name() in algorithmIds]

    # create group folders, <group>/index.rst and processing_algorithms.rst
    print(f'Create *.rst files for {len(algs)} algorithms')
    generateGroupRSTs(rootRst, algs)
    generateAlgorithmRSTs(rootRst, algs, load_process_help=load_process_help)


def wrapWithNewLines(text: str) -> str:
    """
    Ensures that the input text begins and ends with a newline character
    In case it does not end with a newline, 2 empty lines will be appended
    :param text: str
    :return: str
    """

    if isinstance(text, str) and len(text) > 0:
        if text[0] != '\n':
            text = '\n' + text
        if text[-1] != '\n':
            text += '\n\n'
        return text
    else:
        return ''


def wrapAutoGenerated(rst_text: Union[str, list], section: str) -> str:
    if isinstance(rst_text, list):
        rst_text = '\n'.join(rst_text)

    """Wraps autogenerated content with start and end markers"""
    return f"\n{PREFIX_AUTOGEN}{section} START\n{wrapWithNewLines(rst_text)}\n{PREFIX_AUTOGEN}{section} END\n\n"


rx_needs_escape = re.compile(r'(?<!\\)([*|<>()\[\]])')


def escape_rst(text: str) -> str:
    if text is None:
        return ''
    parts = re.findall('(`[^`]*`_|[^`]*)', text)
    for i, part in enumerate(parts):
        if not (part.startswith('`') and part.endswith('`_')):
            parts[i] = rx_needs_escape.sub(r'\\\g<1>', part)

    return ''.join(parts)


def collectQgsProcessAlgorithmHelp(algorithms: List[QgsProcessingAlgorithm], run_async: bool = False) -> Dict[str, str]:
    results = dict()
    n = len(algorithms)

    if not run_async:
        for alg in algorithms:
            results[alg.id()] = qgisProcessHelp(alg)
    else:
        def process_algorithm(alg):
            return alg.id(), qgisProcessHelp(alg)

        with ThreadPoolExecutor(max_workers=min(10, os.cpu_count())) as executor:
            futures = executor.map(process_algorithm, algorithms)

        for alg_id, help_text in futures:
            results[alg_id] = help_text

    return results


def rst_label(algorithm: QgsProcessingAlgorithm) -> str:
    """
    Creates an RST label to refer to the algorithm description of the QgsProcessingAlgorithm
    :param algorithm: QgsProcessingAlgorithm
    :return: str
    """
    return f'alg-{algorithm.id().replace(':', '-')}'


def v3(alg: QgsProcessingAlgorithm, section_adds: dict = None, qgis_process_help: dict = None):
    """

    :param alg: QgsProcessingAlgorithm
    :param section_adds: dictionary with rst code snippeds to append to an autogenerated section.
    """
    if isinstance(alg, EnMAPProcessingAlgorithm):
        helpParameters = {k: v for k, v in alg.helpParameters()}
    else:
        helpParameters = dict()

    if section_adds is None:
        section_adds = dict()
    if qgis_process_help is None:
        qgis_process_help = dict()

    # Title Section
    title = alg.displayName()
    dotline = '*' * len(title)
    title_text = f".. _{rst_label(alg)}:\n\n{dotline}\n{title}\n{dotline}\n"
    title_text = utilsConvertHtmlLinksToRstLinks(title_text)  # Convert any HTML links

    text = wrapAutoGenerated(title_text, "TITLE")
    text += wrapWithNewLines(section_adds.get('TITLE'))

    # Description Section
    description_text = injectGlossaryLinks(alg.shortDescription())
    description_text = utilsConvertHtmlLinksToRstLinks(description_text)
    description_text = escape_rst(description_text)
    text += wrapAutoGenerated(description_text, "DESCRIPTION")
    text += wrapWithNewLines(section_adds.get('DESCRIPTION'))

    # Parameters Section
    param_text = '**Parameters**\n\n'
    outputsHeadingCreated = False
    for pd in alg.parameterDefinitions():
        assert isinstance(pd, QgsProcessingParameterDefinition)

        pdhelp = helpParameters.get(pd.description(), pd.help())

        if not outputsHeadingCreated and isinstance(pd, QgsProcessingDestinationParameter):
            param_text += '\n\n**Outputs**\n\n'
            outputsHeadingCreated = True

        param_text += f'\n:guilabel:`{pd.description()}` [{pd.type()}]\n'
        pdhelp = injectGlossaryLinks(pdhelp)
        pdhelp = utilsConvertHtmlLinksToRstLinks(pdhelp)  # Convert HTML links in help text
        for line in pdhelp.split('\n'):
            param_text += f'    {escape_rst(line)}\n'

        if pd.defaultValue() is not None:
            if isinstance(pd.defaultValue(), str) and '\n' in pd.defaultValue():
                param_text += '    Default::\n\n'
                for line in pd.defaultValue().split('\n'):
                    param_text += f'        {escape_rst(line)}\n'
            else:
                param_text += f'    Default: *{escape_rst(str(pd.defaultValue()))}*\n\n'

    text += wrapAutoGenerated(param_text, "PARAMETERS")
    text += wrapWithNewLines(section_adds.get('PARAMETERS'))

    # Command-line usage
    if alg.id() in qgis_process_help:
        helptext = qgis_process_help[alg.id()]
        helptext = helptext[helptext.find('----------------\nArguments\n----------------'):]
        helptext = utilsConvertHtmlLinksToRstLinks(helptext)  # Convert HTML links in usage text

        usage_text = f"**Command-line usage**\n\n``>qgis_process help {alg.id()}``::\n\n"
        usage_text += '\n'.join([f'    {line}' for line in helptext.splitlines()])

        text += wrapAutoGenerated(usage_text, "COMMAND USAGE")
        text += wrapWithNewLines(section_adds.get('COMMAND USAGE'))

    return text


def qgisProcessHelp(algorithm: QgsProcessingAlgorithm) -> str:
    result = subprocess.run(['qgis_process', 'help', algorithm.id()],
                            env=QGIS_PROCESS_ENV,
                            stdout=subprocess.PIPE, stderr=subprocess.PIPE
                            )
    if result.returncode != 0:
        s = ""
    assert result.returncode == 0, result.stderr.decode()
    helptext = result.stdout.decode('cp1252')
    return helptext


def utilsConvertHtmlLinksToRstLinks(text: str) -> str:
    """Convert all HTML-style links in the text to RST-style links."""
    links = utilsFindHtmlWeblinks(text)  # Find all HTML links in the text
    for html_link in links:
        rst_link = utilsHtmlWeblinkToRstWeblink(html_link)
        text = text.replace(html_link, rst_link)
    return text


def utilsFindHtmlWeblinks(text) -> List[str]:
    match_: re.Match
    starts = [match_.start() for match_ in re.finditer('<a href="', text)]
    ends = [match_.start() + 4 for match_ in re.finditer('</a>', text)]
    assert len(starts) == len(ends)
    links = [text[start:end] for start, end in zip(starts, ends)]
    return links


def utilsHtmlWeblinkToRstWeblink(htmlText: str) -> str:
    assert htmlText.startswith('<a href="'), htmlText
    assert htmlText.endswith('</a>'), htmlText
    link, name = htmlText[9:-4].split('">')
    rstText = f'`{name} <{link}>`_'
    return rstText


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Generates the documentation for EnMAPBox processing algorithms ',
                                     formatter_class=argparse.RawTextHelpFormatter)

    doc_root_default = doc_repo_root() / 'source' / 'usr_section' / 'usr_manual' / 'processing_algorithms'

    parser.add_argument('-r', '--rst_root',
                        required=False,
                        default=str(doc_root_default),
                        help=f'Root folder to write the RST files. Defaults to {doc_root_default}')

    parser.add_argument('-a', '--algs',
                        required=False,
                        nargs='*',
                        default=None,
                        help='List of algorithms ids to generate the documentation for')

    parser.add_argument('-p', '--skip_processing_help',
                        required=False,
                        default=False,
                        help='Skip loading of qgis_process help (as this takes a while)',
                        action='store_true')

    args = parser.parse_args()

    rootRst = Path(args.rst_root)
    if not rootRst.is_absolute():
        rootRst = rootCodeRepo / rootRst

    assert rootRst.is_dir(), f'Directory does not exists: {rootRst}. Use --rst_root to specify location.'

    start_app()
    enmapbox.initAll()
    generateRST(rootRst, args.algs, load_process_help=not args.skip_processing_help)
